# Milo Journal Backend - Motoko Smart Contract

> **Backend descentralizado para la plataforma acad√©mica Milo Journal construido en Motoko para Internet Computer**

## üéØ Descripci√≥n

Este es el smart contract principal de Milo Journal, implementado en Motoko y desplegado en Internet Computer Protocol (ICP). Gestiona toda la l√≥gica de negocio para la publicaci√≥n acad√©mica descentralizada, incluyendo usuarios, papers, votaci√≥n y econom√≠a de tokens.

## üèóÔ∏è Arquitectura

### Componentes Principales

```
AcademicJournal Actor
‚îú‚îÄ‚îÄ State Management
‚îÇ   ‚îú‚îÄ‚îÄ HashMap<Nat, Paper>           # Storage de papers
‚îÇ   ‚îú‚îÄ‚îÄ HashMap<Principal, User>      # Storage de usuarios
‚îÇ   ‚îî‚îÄ‚îÄ HashMap<Text, Vote>           # Storage de votos
‚îú‚îÄ‚îÄ User Management
‚îÇ   ‚îú‚îÄ‚îÄ registerUser()               # Registro de usuarios
‚îÇ   ‚îî‚îÄ‚îÄ getUserInfo()                # Informaci√≥n de usuario
‚îú‚îÄ‚îÄ Paper Management
‚îÇ   ‚îú‚îÄ‚îÄ submitPaper()                # Env√≠o de papers
‚îÇ   ‚îú‚îÄ‚îÄ getAllPapers()               # Listado de papers
‚îÇ   ‚îú‚îÄ‚îÄ getPaper()                   # Paper espec√≠fico
‚îÇ   ‚îî‚îÄ‚îÄ getPapersByStatus()          # Filtrado por estado
‚îú‚îÄ‚îÄ Voting System
‚îÇ   ‚îî‚îÄ‚îÄ votePaper()                  # Sistema de votaci√≥n
‚îî‚îÄ‚îÄ Analytics
    ‚îî‚îÄ‚îÄ getSystemStats()             # Estad√≠sticas del sistema
```

## üìä Tipos de Datos

### PaperStatus
Estados posibles de un paper acad√©mico:

```motoko
public type PaperStatus = {
    #Proposal;   // Propuesta inicial (0 votos)
    #InProcess;  // En proceso de revisi√≥n (-2 a +2 votos)
    #Approved;   // Aprobado por la comunidad (+3 votos)
    #Rejected;   // Rechazado por la comunidad (-3 votos)
};
```

### Paper
Estructura principal de un paper acad√©mico:

```motoko
public type Paper = {
    id: Nat;                    // ID √∫nico del paper
    title: Text;                // T√≠tulo del paper
    author: Text;               // Nombre del autor
    authorPrincipal: Principal; // Principal del autor en IC
    content: Text;              // Contenido/abstract del paper
    status: PaperStatus;        // Estado actual del paper
    timestamp: Int;             // Timestamp de creaci√≥n
    votes: Int;                 // Suma neta de votos (+1 approve, -1 reject)
    reviewers: [Principal];     // Lista de revisores que han votado
};
```

### User
Perfil de usuario en la plataforma:

```motoko
public type User = {
    principal: Principal;       // Principal √∫nico del usuario
    username: Text;             // Nombre de usuario elegido
    walletAmount: Nat;          // Cantidad de tokens $INV
    publishedPapers: [Nat];     // IDs de papers publicados
    reviewedPapers: [Nat];      // IDs de papers revisados
};
```

### Vote
Registro de un voto en un paper:

```motoko
public type Vote = {
    paperId: Nat;               // ID del paper votado
    voter: Principal;           // Principal del votante
    approve: Bool;              // true = aprobar, false = rechazar
    timestamp: Int;             // Timestamp del voto
};
```

## üí∞ Econom√≠a de Tokens ($INV)

### Flujo de Tokens

| Acci√≥n | Costo/Recompensa | Descripci√≥n |
|--------|------------------|-------------|
| **Registro inicial** | +1000 $INV | Tokens gratuitos al registrarse |
| **Publicar paper** | -100 $INV | Costo por enviar un paper |
| **Votar en paper** | +50 $INV | Recompensa por participar en peer review |

### Validaciones Econ√≥micas

- ‚úÖ **Verificaci√≥n de balance**: Antes de deducir tokens
- ‚úÖ **Prevenci√≥n double-spending**: Control de operaciones concurrentes
- ‚úÖ **L√≠mites de votaci√≥n**: Un voto por paper por usuario
- ‚úÖ **Anti-auto-votaci√≥n**: Usuarios no pueden votar sus propios papers

## üîß API Reference

### Gesti√≥n de Usuarios

#### `registerUser(username: Text) -> Result<Text, Text>`
Registra un nuevo usuario en la plataforma.

**Par√°metros:**
- `username`: Nombre de usuario deseado

**Retorno:**
- `Result<Text, Text>`: "Usuario registrado exitosamente" o mensaje de error

**Validaciones:**
- ‚úÖ Usuario no debe estar ya registrado
- ‚úÖ Username no puede estar vac√≠o

**Ejemplo:**
```motoko
let result = await actor.registerUser("Dr. Smith");
// Result: #ok("Usuario registrado exitosamente")
```

#### `getUserInfo() -> Result<User, Text>`
Obtiene informaci√≥n del usuario autenticado.

**Retorno:**
- `Result<User, Text>`: Datos del usuario o "Usuario no encontrado"

**Ejemplo:**
```motoko
let userInfo = await actor.getUserInfo();
// Result: #ok({principal = ...; username = "Dr. Smith"; walletAmount = 1000; ...})
```

### Gesti√≥n de Papers

#### `submitPaper(title: Text, content: Text) -> Result<Nat, Text>`
Env√≠a un nuevo paper a la plataforma.

**Par√°metros:**
- `title`: T√≠tulo del paper
- `content`: Contenido/abstract del paper

**Retorno:**
- `Result<Nat, Text>`: ID del paper creado o mensaje de error

**Validaciones:**
- ‚úÖ Usuario debe estar registrado
- ‚úÖ Usuario debe tener al menos 100 $INV
- ‚úÖ T√≠tulo y contenido no pueden estar vac√≠os

**Ejemplo:**
```motoko
let paperId = await actor.submitPaper(
    "Quantum Computing Applications", 
    "This paper explores..."
);
// Result: #ok(42)  // Nuevo paper con ID 42
```

#### `getAllPapers() -> [Paper]`
Obtiene todos los papers de la plataforma.

**Retorno:**
- `[Paper]`: Array con todos los papers

**Ejemplo:**
```motoko
let papers = await actor.getAllPapers();
// Result: [{id=1; title="Paper 1"; ...}, {id=2; title="Paper 2"; ...}]
```

#### `getPaper(paperId: Nat) -> Result<Paper, Text>`
Obtiene un paper espec√≠fico por su ID.

**Par√°metros:**
- `paperId`: ID del paper a obtener

**Retorno:**
- `Result<Paper, Text>`: Datos del paper o "Paper no encontrado"

#### `getPapersByStatus(status: PaperStatus) -> [Paper]`
Filtra papers por su estado actual.

**Par√°metros:**
- `status`: Estado a filtrar (#Proposal, #InProcess, #Approved, #Rejected)

**Retorno:**
- `[Paper]`: Array con papers del estado especificado

**Ejemplo:**
```motoko
let proposals = await actor.getPapersByStatus(#Proposal);
// Result: Papers en estado "Proposal"
```

### Sistema de Votaci√≥n

#### `votePaper(paperId: Nat, approve: Bool) -> Result<Text, Text>`
Registra un voto en un paper espec√≠fico.

**Par√°metros:**
- `paperId`: ID del paper a votar
- `approve`: true para aprobar, false para rechazar

**Retorno:**
- `Result<Text, Text>`: "Voto registrado exitosamente" o mensaje de error

**Validaciones:**
- ‚úÖ Paper debe existir
- ‚úÖ Usuario no puede votar su propio paper
- ‚úÖ Usuario no puede votar dos veces el mismo paper
- ‚úÖ Usuario debe estar registrado

**L√≥gica de Estados:**
- **+3 votos netos** ‚Üí Paper pasa a `#Approved`
- **-3 votos netos** ‚Üí Paper pasa a `#Rejected`
- **Entre -2 y +2** ‚Üí Paper permanece en `#InProcess`

**Ejemplo:**
```motoko
let result = await actor.votePaper(42, true);  // Votar aprobar
// Result: #ok("Voto registrado exitosamente")
// Usuario recibe +50 $INV
```

### Estad√≠sticas

#### `getSystemStats() -> {totalPapers: Nat; totalUsers: Nat; approvedPapers: Nat}`
Obtiene estad√≠sticas generales del sistema.

**Retorno:**
- Objeto con m√©tricas del sistema

**Ejemplo:**
```motoko
let stats = await actor.getSystemStats();
// Result: {totalPapers = 125; totalUsers = 45; approvedPapers = 78}
```

## üîê Seguridad

### Autenticaci√≥n
- Todos los m√©todos `shared(msg)` verifican la identidad del caller
- Uso del Principal de Internet Identity para autenticaci√≥n

### Autorizaci√≥n
- Solo propietarios pueden realizar ciertas acciones
- Verificaci√≥n de ownership en operaciones sensibles

### Validaciones de Negocio
1. **Balance checking**: Verificaci√≥n antes de deducir tokens
2. **Vote uniqueness**: Prevenci√≥n de votos duplicados
3. **Self-voting prevention**: Usuarios no pueden votar sus propios papers
4. **State consistency**: Estados de papers se actualizan autom√°ticamente

### Gesti√≥n de Estado
- Uso de `stable` variables para persistencia entre upgrades
- HashMap eficientes para operaciones de lectura/escritura
- Manejo robusto de errores con `Result` types

## üß™ Testing

### M√©todos de Testing Local

```bash
# Verificar sintaxis Motoko
moc --check src/milo_journal_backend/main.mo

# Desplegar localmente
dfx deploy milo_journal_backend

# Probar m√©todos espec√≠ficos
dfx canister call milo_journal_backend registerUser '("Dr. Test")'
dfx canister call milo_journal_backend getUserInfo '()'
dfx canister call milo_journal_backend submitPaper '("Test Paper", "Content")'
dfx canister call milo_journal_backend getAllPapers '()'
dfx canister call milo_journal_backend votePaper '(0, true)'
dfx canister call milo_journal_backend getSystemStats '()'
```

### Casos de Prueba

#### Test 1: Flujo Completo de Usuario
```bash
# 1. Registrar usuario
dfx canister call milo_journal_backend registerUser '("Alice")'

# 2. Verificar balance inicial (1000 tokens)
dfx canister call milo_journal_backend getUserInfo '()'

# 3. Publicar paper (costo: 100 tokens)
dfx canister call milo_journal_backend submitPaper '("AI Paper", "Abstract here")'

# 4. Verificar balance actualizado (900 tokens)
dfx canister call milo_journal_backend getUserInfo '()'
```

#### Test 2: Sistema de Votaci√≥n
```bash
# Como usuario diferente, votar el paper
dfx identity new bob
dfx identity use bob
dfx canister call milo_journal_backend registerUser '("Bob")'
dfx canister call milo_journal_backend votePaper '(0, true)'

# Verificar que Bob recibi√≥ recompensa (+50 tokens)
dfx canister call milo_journal_backend getUserInfo '()'
```

## üìà Performance

### Complejidad de Operaciones

| Operaci√≥n | Complejidad | Notas |
|-----------|-------------|-------|
| `registerUser` | O(1) | HashMap lookup + insert |
| `getUserInfo` | O(1) | HashMap lookup |
| `submitPaper` | O(1) | HashMap insert + update |
| `getAllPapers` | O(n) | Itera todos los papers |
| `votePaper` | O(1) | HashMap operations |
| `getPapersByStatus` | O(n) | Filtra todos los papers |

### Optimizaciones
- Uso de HashMap para lookups O(1)
- Lazy evaluation en queries
- Minimizaci√≥n de clonado de datos
- Eficiencia en operaciones de estado

## üîÑ Upgrade Strategy

### Estado Stable
```motoko
private stable var nextPaperId: Nat = 0;
```

### Migraci√≥n de Datos
- Variables marcadas como `stable` persisten entre upgrades
- HashMap requieren serializaci√≥n/deserializaci√≥n manual
- Backup de estado cr√≠tico antes de upgrades

## üöÄ Deployment

### Local Development
```bash
dfx start --background
dfx deploy milo_journal_backend
```

### Mainnet Deployment
```bash
dfx deploy --network ic milo_journal_backend
```

### Canister Management
```bash
# Obtener canister ID
dfx canister id milo_journal_backend

# Ver informaci√≥n del canister
dfx canister info milo_journal_backend

# Upgrade canister
dfx deploy milo_journal_backend --mode upgrade
```

## üìä Monitoreo

### M√©tricas Importantes
- N√∫mero total de usuarios registrados
- Papers publicados por estado
- Volumen de votos por per√≠odo
- Distribuci√≥n de tokens en el sistema

### Logs y Debug
```motoko
Debug.print("Registrando usuario: " # username);
```

## üêõ Troubleshooting

### Errores Comunes

| Error | Causa | Soluci√≥n |
|-------|-------|----------|
| "Usuario ya registrado" | Doble registro | Verificar con `getUserInfo()` |
| "Fondos insuficientes" | Balance < 100 tokens | Votar papers para ganar tokens |
| "Ya has votado en este paper" | Voto duplicado | Un voto por paper por usuario |
| "Paper no encontrado" | ID inv√°lido | Verificar IDs con `getAllPapers()` |

### Debug Tips
1. Usar `Debug.print()` para logging
2. Verificar estado con query methods
3. Revisar argumentos de entrada
4. Confirmar identidad del caller

---

**Milo Journal Backend v1.0.0** - Smart contract en Motoko para publicaci√≥n acad√©mica descentralizada.

*√öltima actualizaci√≥n: Enero 2025*